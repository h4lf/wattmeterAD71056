/*
 * nokia5110.c
 *
 * Created: 17.05.2016 19:30:03
 *  Author: UB4LAG Vasily Afanasyev
 */ 

#include "pin_macros.h"
#include <util/delay.h>
#include <avr/pgmspace.h>
#include "nokia5110.h"

const unsigned char LcdTable[480] PROGMEM =
{	0x00,0x00,0x00,0x00,0x00,    // 20 space        ASCII table for NOKIA LCD: 96 rows * 5 bytes= 480 bytes
	0x00,0x00,0x5f,0x00,0x00,    // 21 !            Note that this is the same set of codes for character you
	0x00,0x07,0x00,0x07,0x00,    // 22 "            would find on a HD44780 based character LCD. :)
	0x14,0x7f,0x14,0x7f,0x14,    // 23 #            Also, given the size of the LCD (84 pixels by 48 pixels),
	0x24,0x2a,0x7f,0x2a,0x12,    // 24 $            the maximum number of characters per row is only 14. :)
	0x23,0x13,0x08,0x64,0x62,    // 25 %
	0x36,0x49,0x55,0x22,0x50,    // 26 &
	0x00,0x05,0x03,0x00,0x00,    // 27 '
	0x00,0x1c,0x22,0x41,0x00,    // 28 (
	0x00,0x41,0x22,0x1c,0x00,    // 29 )
	0x14,0x08,0x3e,0x08,0x14,    // 2a *
	0x08,0x08,0x3e,0x08,0x08,    // 2b +
	0x00,0x50,0x30,0x00,0x00,    // 2c ,
	0x08,0x08,0x08,0x08,0x08,    // 2d -
	0x00,0x60,0x60,0x00,0x00,    // 2e .
	0x20,0x10,0x08,0x04,0x02,    // 2f /
	0x3e,0x51,0x49,0x45,0x3e,    // 30 0
	0x00,0x42,0x7f,0x40,0x00,    // 31 1
	0x42,0x61,0x51,0x49,0x46,    // 32 2
	0x21,0x41,0x45,0x4b,0x31,    // 33 3
	0x18,0x14,0x12,0x7f,0x10,    // 34 4
	0x27,0x45,0x45,0x45,0x39,    // 35 5
	0x3c,0x4a,0x49,0x49,0x30,    // 36 6
	0x01,0x71,0x09,0x05,0x03,    // 37 7
	0x36,0x49,0x49,0x49,0x36,    // 38 8
	0x06,0x49,0x49,0x29,0x1e,    // 39 9
	0x00,0x36,0x36,0x00,0x00,    // 3a :
	0x00,0x56,0x36,0x00,0x00,    // 3b ;
	0x08,0x14,0x22,0x41,0x00,    // 3c <
	0x14,0x14,0x14,0x14,0x14,    // 3d =
	0x00,0x41,0x22,0x14,0x08,    // 3e >
	0x02,0x01,0x51,0x09,0x06,    // 3f ?
	0x32,0x49,0x79,0x41,0x3e,    // 40 @
	0x7e,0x11,0x11,0x11,0x7e,    // 41 A
	0x7f,0x49,0x49,0x49,0x36,    // 42 B
	0x3e,0x41,0x41,0x41,0x22,    // 43 C
	0x7f,0x41,0x41,0x22,0x1c,    // 44 D
	0x7f,0x49,0x49,0x49,0x41,    // 45 E
	0x7f,0x09,0x09,0x09,0x01,    // 46 F
	0x3e,0x41,0x49,0x49,0x7a,    // 47 G
	0x7f,0x08,0x08,0x08,0x7f,    // 48 H
	0x00,0x41,0x7f,0x41,0x00,    // 49 I
	0x20,0x40,0x41,0x3f,0x01,    // 4a J
	0x7f,0x08,0x14,0x22,0x41,    // 4b K
	0x7f,0x40,0x40,0x40,0x40,    // 4c L
	0x7f,0x02,0x0c,0x02,0x7f,    // 4d M
	0x7f,0x04,0x08,0x10,0x7f,    // 4e N
	0x3e,0x41,0x41,0x41,0x3e,    // 4f O
	0x7f,0x09,0x09,0x09,0x06,    // 50 P
	0x3e,0x41,0x51,0x21,0x5e,    // 51 Q
	0x7f,0x09,0x19,0x29,0x46,    // 52 R
	0x46,0x49,0x49,0x49,0x31,    // 53 S
	0x01,0x01,0x7f,0x01,0x01,    // 54 T
	0x3f,0x40,0x40,0x40,0x3f,    // 55 U
	0x1f,0x20,0x40,0x20,0x1f,    // 56 V
	0x3f,0x40,0x38,0x40,0x3f,    // 57 W
	0x63,0x14,0x08,0x14,0x63,    // 58 X
	0x07,0x08,0x70,0x08,0x07,    // 59 Y
	0x61,0x51,0x49,0x45,0x43,    // 5a Z
	0x00,0x7f,0x41,0x41,0x00,    // 5b [
	0x40,0x00,0x40,0x00,0x40,    // 5c \ (...)
	0x00,0x41,0x41,0x7f,0x00,    // 5d ]
	0x04,0x02,0x01,0x02,0x04,    // 5e ^
	0x40,0x40,0x40,0x40,0x40,    // 5f _
	0x00,0x01,0x02,0x04,0x00,    // 60 `
	0x20,0x54,0x54,0x54,0x78,    // 61 a
	0x7f,0x48,0x44,0x44,0x38,    // 62 b
	0x38,0x44,0x44,0x44,0x20,    // 63 c
	0x38,0x44,0x44,0x48,0x7f,    // 64 d
	0x38,0x54,0x54,0x54,0x18,    // 65 e
	0x08,0x7e,0x09,0x01,0x02,    // 66 f
	0x0c,0x52,0x52,0x52,0x3e,    // 67 g
	0x7f,0x08,0x04,0x04,0x78,    // 68 h
	0x00,0x44,0x7d,0x40,0x00,    // 69 i
	0x20,0x40,0x44,0x3d,0x00,    // 6a j
	0x7f,0x10,0x28,0x44,0x00,    // 6b k
	0x00,0x41,0x7f,0x40,0x00,    // 6c l
	0x7c,0x04,0x18,0x04,0x78,    // 6d m
	0x7c,0x08,0x04,0x04,0x78,    // 6e n
	0x38,0x44,0x44,0x44,0x38,    // 6f o
	0x7c,0x14,0x14,0x14,0x08,    // 70 p
	0x08,0x14,0x14,0x18,0x7c,    // 71 q
	0x7c,0x08,0x04,0x04,0x08,    // 72 r
	0x48,0x54,0x54,0x54,0x20,    // 73 s
	0x04,0x3f,0x44,0x40,0x20,    // 74 t
	0x3c,0x40,0x40,0x20,0x7c,    // 75 u
	0x1c,0x20,0x40,0x20,0x1c,    // 76 v
	0x3c,0x40,0x30,0x40,0x3c,    // 77 w
	0x44,0x28,0x10,0x28,0x44,    // 78 x
	0x0c,0x50,0x50,0x50,0x3c,    // 79 y
	0x44,0x64,0x54,0x4c,0x44,    // 7a z
	0x04,0x06,0x07,0x06,0x04,    // 7b { (UP)
	0x14,0x36,0x77,0x36,0x14,    // 7c | (UP+DOWN)
	0x10,0x30,0x70,0x30,0x10,    // 7d } (DOWN)
	0x08,0x08,0x2a,0x1c,0x08,    // 7e Right Arrow     -> (~)
	0x08,0x1c,0x2a,0x08,0x08	 // 7f Left Arrow    <-
};



void lcd_init_gpio(void)
{
	DRIVER(LCD_SCK, OUT);
	DRIVER(LCD_SDI, OUT);
	DRIVER(LCD_D_C, OUT);
	DRIVER(LCD_SCE, OUT);
	DRIVER(LCD_RES, OUT);
	
	SET(LCD_SCK);
	SET(LCD_SDI);
	SET(LCD_D_C);
	SET(LCD_SCE);
	SET(LCD_RES);
}

void lcd_init(void)
{
	lcd_init_gpio();
	_delay_ms(10);
	CLR(LCD_RES);         // Reset the LCD.
	_delay_ms(100);       // Wait 100ms.
	SET(LCD_RES);          // Awake LCD from RESET state.

	lcd_write_command(0x21);     // Activate Chip and H=1.
	lcd_write_command(0xC2);     // Set LCD Voltage to about 7V.
	lcd_write_command(0x13);     // Adjust voltage bias.
	lcd_write_command(0x20);     // Horizontal addressing and H=0.
	lcd_write_command(0x09);     // Activate all segments.
	lcd_clear_ram();             // Erase all pixel on the DDRAM.
	lcd_write_command(0x08);     // Blank the Display.
	lcd_write_command(0x0C);     // Display Normal.
	lcd_cursor_xy(0,0);          // Cursor Home.
}

void lcd_write_command(uint8_t CommandIn)
{
	CLR(LCD_D_C);				// Select Command register.
	CLR(LCD_SCE);				// Select Chip.
	lcd_clock_data(CommandIn);	// Clock in command bits.
	SET(LCD_SCE);				// Deselect Chip.
}

void lcd_write_data(uint8_t DataIn)
{
	SET(LCD_D_C);				// Select Data register.
	CLR(LCD_SCE);				// Select Chip.
	lcd_clock_data(DataIn);		// Clock in command bits.
	SET(LCD_SCE);				// Deselect Chip.
}

void lcd_clock_data(uint8_t DataIn)
{
	uint8_t i;
	
	for (i=8; i>0; i--)
	{
		CLR(LCD_SCK);
		if (DataIn & 0x80)
		{
			SET(LCD_SDI);
		}
		else
		{
			CLR(LCD_SDI);
		}
		SET(LCD_SCK);
		DataIn <<= 1;
	}
}

void lcd_clear_ram(void)
{
	uint16_t Ddram;

	lcd_cursor_xy(0, 0);	// Cursor Home.
	for (Ddram = 504; Ddram > 0; Ddram--)
	{
		lcd_write_data(0x00);	// 6*84 = 504 DDRAM addresses.
	}
}

void lcd_clear_str(uint8_t Len)		// Очистка строки на N пикселей
{
	uint8_t Count;
	
	for (Count = Len; Count > 0; Count--) lcd_write_data(0x00);
}

void lcd_cursor_xy(unsigned char X, unsigned char Y)// Position cursor to x,y. где x в пикселях, а y номер строки
{
	 lcd_write_command(0x40 | (Y & 0x07));    // Y axis
	 lcd_write_command(0x80 | (X & 0x7f));    // X axis
}

void lcd_put_char(char Character)	// Write one character.
{
	unsigned int Count, CharColumn;

	if ((Character < 0x20) || (Character > 0x7f)) return;		// Exit function if character is not found.

	for (Count = 0; Count < 5; Count++)							// Draw the columns to print the character.
	{
		CharColumn = pgm_read_byte(&(LcdTable[(Character - 32) * 5 + Count]));
		lcd_write_data(CharColumn);
	}
	lcd_write_data(0x00);										// 1 pixel spacing per character.
}

void lcd_put_str_pgm(const char *PtrStr)				// Writes a string of characters (in flash).
{
	uint8_t Character;
	while((Character = pgm_read_byte(PtrStr++)) != '\0')
	{
		lcd_put_char(Character); // Points to one ASCII to be written one at a time.
	}
}

void lcd_put_str_ram(char *PtrStr)			// Writes a string of characters (in RAM).
{
	while( *PtrStr != '\0')
	{
		lcd_put_char(*PtrStr++);
	}
}

void lcd_put_hex_byte(uint8_t Byte)
{
	uint8_t tmp_char;
	tmp_char = ((Byte>>4)&0x0f)+0x30;
	lcd_put_char((tmp_char<0x3a)?tmp_char:(tmp_char+7));
	tmp_char = (Byte&0x0f)+0x30;
	lcd_put_char((tmp_char<0x3a)?tmp_char:(tmp_char+7));
}
